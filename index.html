<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Game Era Selector – Pixel Pioneers Playable</title>
  <style>
    body { background: linear-gradient(120deg,#181824 0%,#27293d 100%); color: #fff; font-family: 'Segoe UI', Arial, sans-serif; margin: 0; padding: 0;}
    .container { max-width: 1200px; padding: 30px 20px; margin: auto;}
    h1, h2 { text-align: center;}
    .game-section { margin-bottom: 50px;}
    .game-grid { display: grid; grid-template-columns: repeat(auto-fit,minmax(170px,1fr)); gap: 20px; margin-top: 25px;}
    .game-card { background: rgba(30,30,60,0.93); border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.14); padding: 18px; min-height: 130px; transition: transform 0.15s, box-shadow 0.15s; position: relative; cursor: pointer; overflow: hidden;}
    .game-card.old-school { border-left: 4px solid #46ecfd; border-bottom: 3px dashed #2fd1e6; background: linear-gradient(135deg,#232345 85%,#15353c 100%); box-shadow: 0 0 12px #27c1f766;}
    .game-card.new-school { border-left: 4px solid #fd4674; border-bottom: 3px solid #fd4674; background: linear-gradient(135deg,#26263d 60%,#421d33 100%); box-shadow: 0 0 12px #fd467455;}
    .game-card:hover, .game-card:focus-visible { transform: translateY(-2px) scale(1.025); box-shadow: 0 8px 24px rgba(46,236,253,0.13),0 1.5px 4px #0006; z-index: 2;}
    .game-title { font-weight: bold; font-size: 1.14em; margin-bottom: 6px; letter-spacing: 0.02em;}
    .game-era { font-size: 0.92em; color: #9cf7f6; opacity: 0.8; margin-bottom: 5px;}
    .game-desc { font-size: 0.97em; color: #e3e3e3; margin-top: 12px; max-height: 0; overflow: hidden; opacity: 0; transition: max-height 0.5s, opacity 0.45s; pointer-events: none;}
    .game-card.active .game-desc { max-height: 100px; opacity: 1; pointer-events: auto;}
    .game-btn, .play-btn { background: linear-gradient(90deg,#46ecfd,#fd4674); border: none; color: #fff; padding: 7px 16px; border-radius: 17px; font-weight: bold; font-size: 0.99em; position: absolute; bottom: 16px; right: 16px; cursor: pointer; transition: background 0.22s; z-index: 2;}
    .game-btn:hover, .game-btn:focus-visible,
    .play-btn:hover, .play-btn:focus-visible { background: linear-gradient(90deg,#fd4674,#46ecfd); outline: none;}
    .play-btn { left: 16px; right: auto; bottom: 16px; }
    @media (max-width: 750px) { .game-grid { grid-template-columns: 1fr 1fr; } }
    @media (max-width: 500px) { .game-grid { grid-template-columns: 1fr; } .container { padding: 18px 4px;} }
    .search-bar { width: 100%; margin-bottom: 30px; padding: 10px 16px; border-radius: 8px; border: none; font-size: 1em; outline: none; background: #222231; color: #fff; box-shadow: 0 0.5px 1px #0006; margin-top: 10px; margin-bottom: 36px; letter-spacing: 0.02em;}
    ::placeholder { color: #a0adc7; opacity: 0.93;}
    .no-results { color: #fd4674; text-align: center; margin: 24px 0 10px; font-size: 1.1em;}
    /* Game Modal styles */
    .modal-bg {
      display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100vw; height: 100vh;
      background: rgba(24,24,32,0.98); align-items: center; justify-content: center;
      transition: opacity 0.18s; opacity: 0;
    }
    .modal-bg.active { display: flex; opacity: 1; }
    .game-modal {
      background: #191933;
      border-radius: 16px;
      box-shadow: 0 0 48px #00f2ff33, 0 2px 16px #0009;
      padding: 0;
      position: relative;
      max-width: 95vw;
      max-height: 97vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      animation: modalIn 0.33s cubic-bezier(.45,1.36,.6,.96);
    }
    @keyframes modalIn {
      from { transform: translateY(40px) scale(0.95); opacity: 0; }
      to { transform: none; opacity: 1;}
    }
    .close-modal {
      position: absolute; top: 12px; right: 14px;
      color: #fff; background: none; border: none; font-size: 1.9em; cursor: pointer; opacity: 0.85;
      z-index: 10; transition: color 0.2s;
    }
    .close-modal:hover { color: #fd4674;}
    .game-canvas-wrap { padding: 22px 20px 10px; }
    .pixel-title { margin-top: 16px; font-weight: bold; letter-spacing: 0.04em; color: #46ecfd;}
    .pixel-status { margin: 5px 0 18px; font-size: 1em; min-height: 1.3em;}
    .modal-btns { margin: 10px 0 17px; }
    .modal-btns button { margin-right: 10px;}
  </style>
</head>
<body>
  <div class="container">
    <h1>Game Era Selector</h1>
    <input class="search-bar" id="gameSearch" placeholder="Search games by name or era..." aria-label="Search games by name or era" autofocus>
    <div class="game-section">
      <h2>Old School Games</h2>
      <div class="game-grid" id="oldSchoolGrid"></div>
      <div class="no-results" id="oldNoResults" style="display:none">No old school games found.</div>
    </div>
    <div class="game-section">
      <h2>New School Games</h2>
      <div class="game-grid" id="newSchoolGrid"></div>
      <div class="no-results" id="newNoResults" style="display:none">No new school games found.</div>
    </div>
  </div>
  <!-- GAME MODAL -->
  <div class="modal-bg" id="modalBg" role="dialog" aria-modal="true" aria-label="Pixel Pioneers Play">
    <div class="game-modal" id="gameModal">
      <button class="close-modal" aria-label="Close" id="closeModal">&times;</button>
      <div class="pixel-title">Pixel Pioneers – Dungeon Maze</div>
      <div class="game-canvas-wrap">
        <canvas id="pixelCanvas" width="400" height="400" tabindex="0"></canvas>
      </div>
      <div class="pixel-status" id="pixelStatus"></div>
      <div class="modal-btns">
        <button class="game-btn" id="restartGame">Restart</button>
      </div>
    </div>
  </div>
  <script>
    // --- Game Data (abbreviated for brevity) ---
    const oldSchoolGames = [
      { title:"Pixel Pioneers", era:"1982", desc:"Navigate mysterious dungeons in classic blocky style." },
      // ... rest of the games (omitted here for brevity)
    ];
    // The rest of your games go here; only Pixel Pioneers will get a Play button.

    // The newSchoolGames array goes here...

    // --- Main Render ---
    function renderGames(games, gridElem, isOldSchool, noResElem) {
      gridElem.innerHTML = "";
      if (games.length === 0) { noResElem.style.display = ''; return; }
      else { noResElem.style.display = 'none'; }
      games.forEach((game, idx) => {
        const card = document.createElement("div");
        card.className = `game-card ${isOldSchool ? "old-school" : "new-school"}`;
        card.tabIndex = 0;
        card.setAttribute('aria-label', `${game.title}, ${game.era}, press Enter or Info for description`);
        card.innerHTML = `
          <div class="game-title">${game.title}</div>
          <div class="game-era">${game.era}</div>
          <div class="game-desc" id="desc-${isOldSchool?'o':'n'}-${idx}">${game.desc}</div>
          <button class="game-btn" tabindex="0" aria-expanded="false" aria-controls="desc-${isOldSchool?'o':'n'}-${idx}">Info</button>
        `;
        if (game.title === "Pixel Pioneers") {
          const playBtn = document.createElement("button");
          playBtn.className = "play-btn";
          playBtn.innerText = "Play";
          playBtn.title = "Play Pixel Pioneers";
          playBtn.onclick = e => { e.stopPropagation(); openPixelGame(); };
          card.appendChild(playBtn);
        }
        const infoBtn = card.querySelector('.game-btn');
        function toggleDesc() {
          const expanded = card.classList.toggle("active");
          infoBtn.setAttribute('aria-expanded', expanded ? "true" : "false");
          if (expanded) closeOtherCards(card);
        }
        infoBtn.onclick = e => { e.stopPropagation(); toggleDesc(); };
        infoBtn.onkeydown = e => { if (e.key==="Enter"||e.key===" ") {e.preventDefault(); toggleDesc();}};
        card.onclick = (evt) => { if (!evt.target.classList.contains("game-btn")) toggleDesc(); };
        card.onkeydown = e => {
          if ((e.key==="Enter"||e.key===" ") && !e.target.classList.contains("game-btn")) {
            e.preventDefault(); toggleDesc();
          }
          if (e.key === "Escape") {
            card.classList.remove("active");
            infoBtn.setAttribute('aria-expanded', "false");
          }
        };
        gridElem.appendChild(card);
      });
    }
    const oldGrid = document.getElementById("oldSchoolGrid");
    const newGrid = document.getElementById("newSchoolGrid");
    const oldNoRes = document.getElementById("oldNoResults");
    const newNoRes = document.getElementById("newNoResults");
    function renderAllFiltered(searchVal) {
      const oFiltered = oldSchoolGames.filter(g =>
        g.title.toLowerCase().includes(searchVal) || g.era.toLowerCase().includes(searchVal)
      );
      const nFiltered = (typeof newSchoolGames !== "undefined" ? newSchoolGames : []).filter(g =>
        g.title.toLowerCase().includes(searchVal) || g.era.toLowerCase().includes(searchVal)
      );
      renderGames(oFiltered, oldGrid, true, oldNoRes);
      renderGames(nFiltered, newGrid, false, newNoRes);
    }
    renderAllFiltered('');
    // Debounced search input
    function debounce(fn, ms) { let timer; return function(...args) { clearTimeout(timer); timer = setTimeout(()=>fn.apply(this,args), ms); } }
    document.getElementById('gameSearch').addEventListener('input', debounce(e => {
      renderAllFiltered(e.target.value.toLowerCase());
    }, 100));
    // Utility
    function closeOtherCards(except) {
      document.querySelectorAll('.game-card.active').forEach(card => { if (card !== except) card.classList.remove('active'); });
    }
    document.body.addEventListener('click', (evt) => { if (!evt.target.closest('.game-card')) closeOtherCards(); });
    document.querySelectorAll('.game-grid').forEach(grid=>{ grid.addEventListener('click', e=>e.stopPropagation()); });
    document.addEventListener('keydown', e => { if (e.key === "Escape") closeOtherCards(); });

    // --- PIXEL PIONEERS MAZE GAME ---
    const modalBg = document.getElementById('modalBg');
    const closeModalBtn = document.getElementById('closeModal');
    const pixelStatus = document.getElementById('pixelStatus');
    const restartBtn = document.getElementById('restartGame');
    const pixelCanvas = document.getElementById('pixelCanvas');
    let gameActive = false, animationId = null;

    function openPixelGame() {
      modalBg.classList.add('active');
      gameActive = true;
      document.body.style.overflow = "hidden";
      startMazeGame();
      setTimeout(()=>pixelCanvas.focus(), 300); // Focus canvas for keys
    }
    function closePixelGame() {
      modalBg.classList.remove('active');
      gameActive = false;
      document.body.style.overflow = "";
      cancelAnimationFrame(animationId);
      pixelStatus.innerHTML = "";
    }
    closeModalBtn.onclick = closePixelGame;
    modalBg.addEventListener('click', function(e){
      if (e.target === modalBg) closePixelGame();
    });
    document.addEventListener('keydown', function(e){
      if (!gameActive) return;
      if (e.key === "Escape") closePixelGame();
    });
    restartBtn.onclick = function(e){
      e.stopPropagation(); startMazeGame();
      setTimeout(()=>pixelCanvas.focus(), 200);
    };

    // MAZE GAME LOGIC
    // -- Maze Grid: 0=empty, 1=wall, 2=player, 3=exit
    const MAZE_W = 13, MAZE_H = 13;
    const CELL = 28, PADDING = 18;
    let maze = [], px = 0, py = 0, ex = 0, ey = 0;
    let moveDir = {x:0, y:0}, moveQueue = [];
    let playerPos = {x:0, y:0}, playerScreen = {x:0, y:0};
    let moving = false, win = false, moveSpeed = 5; // px per frame (hyper smooth)
    function randomMaze(w,h) {
      // Simple DFS maze gen, always solvable, center start, corner exit
      let g = Array.from({length:h},()=>Array(w).fill(1));
      let stack = [[1,1]]; g[1][1]=0;
      let dx=[0,1,0,-1], dy=[-1,0,1,0];
      while (stack.length) {
        let [x,y]=stack[stack.length-1], dirs=[0,1,2,3].sort(()=>Math.random()-0.5), carved=false;
        for (let d of dirs) {
          let nx=x+dx[d]*2, ny=y+dy[d]*2;
          if(ny>0&&ny<h-1&&nx>0&&nx<w-1&&g[ny][nx]===1){
            g[y+dy[d]][x+dx[d]]=0;g[ny][nx]=0;stack.push([nx,ny]);carved=true;break;
          }
        }
        if(!carved)stack.pop();
      }
      g[1][1]=2; g[h-2][w-2]=3; // Player start, exit
      return g;
    }
    function startMazeGame() {
      maze = randomMaze(MAZE_W,MAZE_H);
      for (let y=0;y<MAZE_H;y++) for(let x=0;x<MAZE_W;x++){
        if (maze[y][x]==2) { px=x; py=y; }
        if (maze[y][x]==3) { ex=x; ey=y; }
      }
      playerPos = {x:px, y:py}; playerScreen = {x:px*CELL, y:py*CELL};
      moving = false; win = false; moveDir={x:0,y:0}; moveQueue=[];
      pixelStatus.textContent = '';
      runGameLoop();
    }
    // --- Input handling ---
    pixelCanvas.tabIndex = 0;
    pixelCanvas.addEventListener('keydown', function(e){
      if (!gameActive || win) return;
      let dir = null;
      if (["ArrowUp","w","W"].includes(e.key)) dir = {x:0,y:-1};
      if (["ArrowDown","s","S"].includes(e.key)) dir = {x:0,y:1};
      if (["ArrowLeft","a","A"].includes(e.key)) dir = {x:-1,y:0};
      if (["ArrowRight","d","D"].includes(e.key)) dir = {x:1,y:0};
      if (dir) {
        e.preventDefault();
        // Queue next move if not moving
        if (!moving) attemptMove(dir);
        else moveQueue.push(dir);
      }
    });
    function attemptMove(dir) {
      let nx = playerPos.x + dir.x, ny = playerPos.y + dir.y;
      if (maze[ny] && maze[ny][nx]!==1) {
        moveDir = dir; moving = true;
      }
    }
    // -- Main game loop for smooth movement --
    function runGameLoop() {
      animationId = requestAnimationFrame(runGameLoop);
      const ctx = pixelCanvas.getContext('2d');
      // Draw BG
      ctx.clearRect(0,0,pixelCanvas.width,pixelCanvas.height);
      // Draw maze
      for (let y=0;y<MAZE_H;y++) for(let x=0;x<MAZE_W;x++){
        let cx = x*CELL+PADDING, cy = y*CELL+PADDING;
        if (maze[y][x]===1) { // Wall
          ctx.fillStyle="#232345"; ctx.fillRect(cx,cy,CELL,CELL);
          ctx.strokeStyle="#46ecfd"; ctx.lineWidth=2;
          ctx.strokeRect(cx+2,cy+2,CELL-4,CELL-4);
        }
        else if (maze[y][x]===3) { // Exit
          ctx.fillStyle="#fd4674";
          ctx.fillRect(cx+6,cy+6,CELL-12,CELL-12);
          ctx.strokeStyle="#fff"; ctx.lineWidth=2;
          ctx.strokeRect(cx+6,cy+6,CELL-12,CELL-12);
        }
      }
      // Move player if needed
      if (moving) {
        playerScreen.x += moveDir.x*moveSpeed;
        playerScreen.y += moveDir.y*moveSpeed;
        // Check if arrived
        let dx = playerScreen.x - playerPos.x*CELL, dy = playerScreen.y - playerPos.y*CELL;
        if (Math.abs(dx)>CELL||Math.abs(dy)>CELL) { // Should not happen (speed too high)
          playerScreen.x = (playerPos.x+moveDir.x)*CELL;
          playerScreen.y = (playerPos.y+moveDir.y)*CELL;
        }
        if (Math.abs(playerScreen.x - (playerPos.x+moveDir.x)*CELL) < moveSpeed &&
            Math.abs(playerScreen.y - (playerPos.y+moveDir.y)*CELL) < moveSpeed) {
          // Snap to target
          playerPos.x += moveDir.x; playerPos.y += moveDir.y;
          playerScreen.x = playerPos.x*CELL; playerScreen.y = playerPos.y*CELL;
          moving = false;
          // Check win
          if (maze[playerPos.y][playerPos.x]===3) {
            win = true; pixelStatus.textContent = "🏆 You Escaped the Dungeon! 🏆";
          }
          // Queue next
          if (moveQueue.length) {
            let dir = moveQueue.shift();
            attemptMove(dir);
          }
        }
      }
      // Draw player (glow effect)
      ctx.save();
      let px = playerScreen.x+PADDING, py = playerScreen.y+PADDING;
      for (let r=18;r>0;r-=4) {
        ctx.globalAlpha = 0.11 + 0.11*(r/18);
        ctx.beginPath(); ctx.arc(px+CELL/2,py+CELL/2,r,0,2*Math.PI); ctx.fillStyle="#00fff0"; ctx.fill();
      }
      ctx.globalAlpha = 1.0;
      ctx.fillStyle="#46ecfd";
      ctx.fillRect(px+6,py+6,CELL-12,CELL-12);
      ctx.strokeStyle="#fff"; ctx.lineWidth=2;
      ctx.strokeRect(px+6,py+6,CELL-12,CELL-12);
      ctx.restore();
    }
  </script>
</body>
</html>
